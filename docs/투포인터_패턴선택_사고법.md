# 투포인터 패턴 선택 사고법

> 패턴을 먼저 고르지 말고, **"포인터를 움직이면 값이 어떻게 변하나"를 먼저 분석**한 뒤 패턴을 선택해야 한다.

## 핵심 실수 패턴

"두 수를 고른다" → 익숙한 양 끝 패턴 적용 → 틀림

양 끝 패턴과 같은 방향 패턴은 단순히 "두 수를 고른다"가 아니라, **포인터 이동이 값에 미치는 영향**이 다르다.

---

## 패턴 선택 기준

| 패턴 | 시작 | 목적 | 포인터 이동 원리 |
|------|------|------|-----------------|
| 양 끝 | `l=0, r=n-1` | **합**을 목표값에 맞추기 | 합이 크면 r↓, 작으면 l↑ |
| 같은 방향 | `l=0, r=1` | **차이/범위** 조건 탐색 | 차이 부족하면 r↑, 조건 만족하면 l↑ |

---

## 올바른 사고 순서

### 1단계: 포인터 이동 효과 분석

정렬된 배열 `arr`에서:

```
l을 올리면(l++) → arr[r] - arr[l] 감소 (차이 줄어듦)
r을 올리면(r++) → arr[r] - arr[l] 증가 (차이 커짐)
r을 내리면(r--) → arr[r] - arr[l] 감소 (차이 줄어듦)
```

### 2단계: 조건별 원하는 방향 결정

- 조건 **만족** → 더 작게 만들고 싶음 → `l++`
- 조건 **미달** → 더 크게 만들고 싶음 → `r++`

→ 두 포인터가 **같은 방향**으로 움직여야 한다는 결론

### 3단계: 종료 조건 결정

- 같은 방향: `while (r < n)` — r이 끝까지 가면 탐색 완료
- 양 끝: `while (l < r)` — 포인터가 교차하면 탐색 완료

---

## 예시: 수 고르기 (BOJ 2230)

> 차이가 M 이상인 두 수 중 차이가 가장 작은 값

**잘못된 접근 (양 끝 패턴):**
```javascript
let l = 0, r = n - 1;  // ❌

while (l < r) {
    const sub = arr[r] - arr[l];
    if (sub > m) {
        r--;  // r이 n-1에서 시작해 r++하면 범위 초과
        l++;
    } else if (sub < m) {
        r++;  // 이미 n-1인데 r++?
    }
}
```

**올바른 접근 (같은 방향 패턴):**
```javascript
let l = 0, r = 1;  // ✅

while (r < n) {
    const sub = arr[r] - arr[l];
    if (sub >= m) {
        min = Math.min(min, sub);
        l++;  // 조건 만족 → 차이를 줄여보기 → l 올림
    } else {
        r++;  // 조건 미달 → 차이를 키우기 → r 올림
    }
}
```

---

## 체크리스트

투포인터 문제를 만나면:

- [ ] `l++`하면 목표값이 어떻게 변하나?
- [ ] `r++`하면 목표값이 어떻게 변하나?
- [ ] `r--`가 필요한 상황이 있나? (양 끝 패턴)
- [ ] 포인터가 교차할 수 있나? (양 끝) vs 한쪽이 끝에 도달하나? (같은 방향)

---

## 한 줄 요약

> **"이 문제는 합 문제인가, 차이/범위 문제인가"** — 합이면 양 끝, 차이/범위면 같은 방향
