# 투포인터 (Two Pointers) 완벽 가이드

## 1. 핵심 개념

투포인터는 **두 개의 포인터를 사용해 배열이나 문자열을 탐색**하는 알고리즘입니다.
- 이중 for문 (O(n²)) → 투포인터 (O(n))로 최적화
- 정렬된 배열에서 특히 유용

## 2. 세 가지 핵심 패턴

### 패턴 1: 양쪽 끝에서 시작 (대칭 탐색)
```javascript
let left = 0;
let right = arr.length - 1;

while (left < right) {
    // 조건에 따라 포인터 이동
    if (조건) {
        left++;
    } else {
        right--;
    }
}
```

**언제 사용?**
- 정렬된 배열에서 두 수의 합 찾기
- 팰린드롬 검사
- 특정 합/차이를 만족하는 쌍 찾기

**예제: 두 수의 합이 target인 경우**
```javascript
function twoSum(arr, target) {
    arr.sort((a, b) => a - b);  // 정렬 필수!
    let left = 0;
    let right = arr.length - 1;

    while (left < right) {
        const sum = arr[left] + arr[right];

        if (sum === target) {
            return [left, right];
        } else if (sum < target) {
            left++;   // 합을 키워야 함
        } else {
            right--;  // 합을 줄여야 함
        }
    }
    return null;
}
```

### 패턴 2: 같은 방향 (Fast & Slow)
```javascript
let slow = 0;
let fast = 0;

while (fast < arr.length) {
    if (조건) {
        // slow 위치에 값 저장/처리
        arr[slow] = arr[fast];
        slow++;
    }
    fast++;
}
```

**언제 사용?**
- 배열에서 특정 요소 제거 (in-place)
- 중복 제거
- 조건을 만족하는 요소만 남기기

**예제: 0을 제거하고 앞으로 당기기**
```javascript
function removeZeros(arr) {
    let slow = 0;

    for (let fast = 0; fast < arr.length; fast++) {
        if (arr[fast] !== 0) {
            arr[slow] = arr[fast];
            slow++;
        }
    }

    // 나머지는 0으로 채우기
    while (slow < arr.length) {
        arr[slow++] = 0;
    }

    return arr;
}
// [0,1,0,3,12] → [1,3,12,0,0]
```

### 패턴 3: 슬라이딩 윈도우 (구간 탐색)
```javascript
let left = 0;

for (let right = 0; right < arr.length; right++) {
    // right 확장하며 윈도우에 추가
    windowSum += arr[right];

    // 조건 위반 시 left 축소
    while (조건_위반) {
        windowSum -= arr[left];
        left++;
    }

    // 현재 윈도우 [left, right] 처리
    answer = Math.max(answer, right - left + 1);
}
```

**언제 사용?**
- 연속된 부분 배열의 최대/최소
- 조건을 만족하는 가장 긴/짧은 구간
- 부분 문자열 문제

**예제: 합이 k 이하인 최장 구간**
```javascript
function longestSubarray(arr, k) {
    let left = 0;
    let sum = 0;
    let maxLen = 0;

    for (let right = 0; right < arr.length; right++) {
        sum += arr[right];

        // 조건 위반: 합이 k 초과
        while (sum > k) {
            sum -= arr[left];
            left++;
        }

        maxLen = Math.max(maxLen, right - left + 1);
    }

    return maxLen;
}
```

## 3. 투포인터 사고 흐름

### Step 1: 문제 유형 파악
- [ ] 정렬된 배열에서 조건 만족하는 쌍? → **양쪽 끝 패턴**
- [ ] 배열 in-place 변경/필터링? → **Fast & Slow 패턴**
- [ ] 연속 구간의 최적값? → **슬라이딩 윈도우**

### Step 2: 포인터 초기화
```javascript
// 양쪽 끝
let left = 0, right = n - 1;

// 같은 방향
let slow = 0, fast = 0;

// 슬라이딩 윈도우
let left = 0;
for (let right = 0; ...)
```

### Step 3: 이동 조건 설계
- **증가 조건**: 언제 left++ 또는 right++?
- **감소 조건**: 언제 right--?
- **종료 조건**: while 언제까지?

### Step 4: 시간 복잡도 검증
- 각 포인터는 최대 n번 이동 → **O(n)**
- 정렬이 필요하면 O(n log n)

## 4. 흔한 실수와 해결법

### ❌ 실수 1: 정렬 안 하고 양쪽 끝 패턴 사용
```javascript
// 틀림!
function twoSum(arr, target) {
    let left = 0, right = arr.length - 1;
    // arr이 정렬 안 되어 있으면 작동 안 함
}
```
✅ **해결**: `arr.sort((a, b) => a - b)` 먼저!

### ❌ 실수 2: left와 right가 겹치는 경우 처리 안 함
```javascript
while (left < right) {  // ✅ 등호 없음!
    // left === right는 같은 요소 두 번 사용
}
```

### ❌ 실수 3: 윈도우 축소 조건 놓침
```javascript
// 틀림!
for (let right = 0; right < n; right++) {
    sum += arr[right];
    // left를 언제 이동할지 조건 없음
}
```
✅ **해결**: `while (sum > k) { sum -= arr[left++]; }`

### ❌ 실수 4: 포인터 이동 후 범위 체크 안 함
```javascript
left++;
right--;
// left > right가 될 수 있음!
```
✅ **해결**: `while (left < right)` 조건 유지

## 5. 대표 문제 유형

| 유형 | 문제 | 패턴 |
|------|------|------|
| 합 찾기 | 두 수의 합, 세 수의 합 | 양쪽 끝 |
| 구간 합 | 연속된 부분 수열의 합 | 슬라이딩 윈도우 |
| 중복 제거 | 정렬된 배열 중복 제거 | Fast & Slow |
| 문자열 | 팰린드롬, 애너그램 찾기 | 양쪽 끝 / 윈도우 |
| 최장 구간 | 조건 만족 최장 부분 배열 | 슬라이딩 윈도우 |

## 6. 템플릿 모음

### 템플릿 1: 양쪽 끝에서 조건 찾기
```javascript
function solve(arr, target) {
    arr.sort((a, b) => a - b);
    let left = 0;
    let right = arr.length - 1;

    while (left < right) {
        const value = calculate(arr[left], arr[right]);

        if (value === target) {
            return [left, right];
        } else if (value < target) {
            left++;
        } else {
            right--;
        }
    }

    return null;
}
```

### 템플릿 2: Fast & Slow로 필터링
```javascript
function filterInPlace(arr, condition) {
    let slow = 0;

    for (let fast = 0; fast < arr.length; fast++) {
        if (condition(arr[fast])) {
            arr[slow] = arr[fast];
            slow++;
        }
    }

    arr.length = slow;  // 배열 자르기
    return arr;
}
```

### 템플릿 3: 슬라이딩 윈도우 최적값
```javascript
function maxWindow(arr, constraint) {
    let left = 0;
    let state = 초기값;  // 합, 맵, 카운트 등
    let answer = 0;

    for (let right = 0; right < arr.length; right++) {
        // 윈도우 확장
        state = update(state, arr[right]);

        // 조건 위반 시 축소
        while (!isValid(state, constraint)) {
            state = remove(state, arr[left]);
            left++;
        }

        // 현재 윈도우 평가
        answer = Math.max(answer, right - left + 1);
    }

    return answer;
}
```

## 7. 실전 체크리스트

풀기 전:
- [ ] 정렬이 필요한가? (양쪽 끝 패턴)
- [ ] 포인터 시작 위치는? (0과 n-1 vs 둘 다 0)
- [ ] 종료 조건은? (left < right vs right < n)

구현 중:
- [ ] 포인터 이동 로직이 명확한가?
- [ ] 무한 루프 가능성은 없는가?
- [ ] 배열 범위를 벗어나지 않는가?

디버깅:
- [ ] 엣지 케이스: 빈 배열, 길이 1, 모두 같은 값
- [ ] 포인터가 정상적으로 움직이는가?
- [ ] 시간 복잡도가 O(n) 또는 O(n log n)인가?

## 8. 연습 문제 추천

**초급**
- 두 수의 합 (정렬된 배열)
- 팰린드롬 검사
- 중복 제거

**중급**
- 세 수의 합
- 컨테이너 with Most Water
- 연속된 부분 수열의 합

**고급**
- 가장 긴 부분 문자열 (중복 없이)
- Minimum Window Substring
- Trapping Rain Water

---

**핵심 요약**
1. 양쪽 끝 (left=0, right=n-1): 정렬된 배열에서 조건 찾기
2. Fast & Slow (둘 다 0): in-place 필터링
3. 슬라이딩 윈도우 (left + for right): 연속 구간 최적값
4. 각 포인터는 한 방향으로만 → O(n) 보장
