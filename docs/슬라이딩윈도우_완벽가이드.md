# 슬라이딩 윈도우 (Sliding Window) 완벽 가이드

## 1. 핵심 개념

슬라이딩 윈도우는 **연속된 구간을 효율적으로 탐색**하는 알고리즘이에요.
- 이중 for문 O(n²) → 슬라이딩 윈도우 O(n)로 최적화
- l, r 두 포인터로 구간 `[l, r]`을 표현
- **r은 항상 윈도우 안에 포함** → 윈도우 길이 = `r - l + 1`

---

## 2. 두 가지 패턴

### 패턴 1: 고정 크기 윈도우

윈도우 크기 k가 고정일 때.

```javascript
let sum = 0;

// 첫 윈도우 [0, k-1] 초기화
for (let i = 0; i < k; i++) sum += arr[i];

let answer = sum;

for (let r = k; r < n; r++) {
    sum += arr[r];        // 오른쪽 원소 추가
    sum -= arr[r - k];    // 왼쪽 원소 제거
    answer = Math.max(answer, sum);
}
```

**언제 사용?**
- 크기 k인 연속 부분 배열의 최대합/최솟값
- 고정 길이 윈도우 내 조건 탐색

---

### 패턴 2: 가변 크기 윈도우

조건을 만족하는 가장 짧은/긴 구간을 찾을 때.

```javascript
let l = 0;
let sum = 0;       // 윈도우 상태 (합, 카운트 등)
let answer = Infinity;  // 또는 0

for (let r = 0; r < n; r++) {
    sum += arr[r];          // ① r을 윈도우에 추가

    while (조건 만족) {      // ② 조건 만족하는 동안
        answer = 갱신;       //    답 갱신
        sum -= arr[l++];    //    l을 빼며 윈도우 축소
    }
}
```

**언제 사용?**
- 합이 S 이상인 가장 짧은 구간 → `while (sum >= s)`
- 합이 S 이하인 가장 긴 구간 → `while (sum > s)`
- 조건 만족하는 최소/최대 길이 구간

---

## 3. 자주 하는 실수

### ❌ 실수 1: r을 윈도우 밖으로 초기화

```javascript
// 틀림!
let l = 0, r = 1, sum = arr[0];  // r이 윈도우 밖을 가리킴

while (...) {
    if (sum < s) { sum += arr[r]; r++; }
    if (sum >= s) { min = r - l + 1; ... }  // off by 1 버그
    //                    ^^^^^^^ 실제로는 r - l 이어야 함
}
```

✅ **해결**: r을 0부터 시작해서 for문으로 순서대로 추가

```javascript
for (let r = 0; r < n; r++) {
    sum += arr[r];   // r 추가 후
    // 이제 윈도우는 [l, r], 길이 = r - l + 1
}
```

---

### ❌ 실수 2: if 대신 while로 l 축소 안 함

```javascript
// 틀림! — 한 번만 l을 줄이면 최적 구간을 놓침
if (sum >= s) {
    answer = Math.min(answer, r - l + 1);
    sum -= arr[l++];
}
```

✅ **해결**: `while`로 조건이 유지되는 동안 계속 축소

```javascript
while (sum >= s) {
    answer = Math.min(answer, r - l + 1);
    sum -= arr[l++];
}
```

---

### ❌ 실수 3: 불가능한 경우 처리 누락

```javascript
return answer;  // answer가 Infinity면 오류
```

✅ **해결**: 초기값 체크 후 반환

```javascript
return answer === Infinity ? 0 : answer;
```

---

## 4. 문제 유형별 템플릿

### 합이 S 이상인 최소 길이 구간 (BOJ 1806 부분합)

```javascript
const solution = (n, s, arr) => {
    let l = 0, sum = 0, min = Infinity;

    for (let r = 0; r < n; r++) {
        sum += arr[r];

        while (sum >= s) {
            min = Math.min(min, r - l + 1);
            sum -= arr[l++];
        }
    }

    return min === Infinity ? 0 : min;
};
```

### 합이 S 이하인 최대 길이 구간

```javascript
const solution = (n, s, arr) => {
    let l = 0, sum = 0, max = 0;

    for (let r = 0; r < n; r++) {
        sum += arr[r];

        while (sum > s) {
            sum -= arr[l++];
        }

        max = Math.max(max, r - l + 1);
        // 조건 만족할 때 갱신 (while 밖에서)
    }

    return max;
};
```

> **주의:** 최소 구간은 while **안**에서, 최대 구간은 while **밖**에서 갱신

---

## 5. 문제 인식 방법

| 단서 | 패턴 |
|------|------|
| "연속된 부분 배열" | 슬라이딩 윈도우 |
| "합이 S 이상/이하" | 가변 크기 윈도우 |
| "길이 k인 구간" | 고정 크기 윈도우 |
| "가장 짧은/긴 구간" | 가변 크기 윈도우 |
| "최소/최대 구간 합" | 고정 크기 윈도우 |

---

## 6. 대표 문제

| 문제 | 핵심 조건 | 패턴 |
|------|-----------|------|
| BOJ 1806 부분합 | 합 >= S, 최소 길이 | 가변 (while 안 갱신) |
| BOJ 2003 수들의 합 2 | 합 == S인 구간 수 | 가변 |
| BOJ 11003 최솟값 찾기 | 크기 k 윈도우 최솟값 | 고정 + 덱 |

---

## 핵심 요약

1. `r`은 항상 **윈도우 안** → 길이는 `r - l + 1`
2. `r` 먼저 추가 → 조건 체크 → `l` 축소
3. 최소 구간: `while` **안**에서 갱신 / 최대 구간: `while` **밖**에서 갱신
