# DP (Dynamic Programming) 완벽 가이드

## DP가 뭔가요?

> **"큰 문제를 작은 문제로 나누고, 작은 문제의 답을 저장해서 재사용하는 것"**

**왜 필요한가?**
- 같은 계산을 반복하지 않기 위해
- 완전 탐색은 너무 느림 (시간 초과)

---

## DP 문제 풀이 5단계 사고법

### 1단계: DP 배열 정의하기

**가장 중요한 단계!**

"dp[i]가 무엇을 의미하는가?"를 명확히 정의해야 합니다.

**예시:**
- 계단 오르기: `dp[i] = i번째 계단을 밟았을 때 최대 점수`
- 1로 만들기: `dp[i] = i를 1로 만드는 최소 연산 횟수`
- 동전1: `dp[i] = i원을 만드는 경우의 수`

### 2단계: 기저 사례 (Base Case) 정하기

가장 작은 문제의 답을 직접 정해줍니다.

**예시:**
- 계단 오르기: `dp[1] = stairs[1]`, `dp[2] = stairs[1] + stairs[2]`
- 1로 만들기: `dp[1] = 0` (1은 이미 1이므로 연산 0회)
- 동전1: `dp[0] = 1` (0원을 만드는 방법은 1가지: 아무것도 안 쓰기)

### 3단계: 점화식 세우기

"dp[i]를 구하려면 어떤 값이 필요한가?"

**핵심 질문:**
- i번째 상태에 도달하려면 어디서 왔는가?
- 이전 상태는 무엇인가?

**예시:**
- 계단 오르기: `dp[i] = max(dp[i-2] + stairs[i], dp[i-3] + stairs[i-1] + stairs[i])`
- 1로 만들기: `dp[i] = 1 + min(dp[i/3], dp[i/2], dp[i-1])`
- 동전1: `dp[i] += dp[i - coin]` (각 동전에 대해)

### 4단계: 계산 순서 정하기

작은 문제부터 큰 문제로 계산합니다.

보통은 `for (let i = 기저사례+1; i <= n; i++)`

### 5단계: 답 반환하기

보통은 `dp[n]`이지만, 문제에 따라 다를 수 있습니다.

---

## 문제 유형별 패턴

### 유형 1: 최댓값/최솟값 구하기

**특징:** "최대", "최소", "가장 큰", "가장 작은"

**DP 정의:** `dp[i] = i까지의 최댓값/최솟값`

**점화식:** `dp[i] = max/min(이전 상태들)`

**예시 문제:**
- 계단 오르기 (최대 점수)
- 1로 만들기 (최소 연산)
- 평범한 배낭 (최대 가치)

### 유형 2: 경우의 수 세기

**특징:** "~하는 방법의 수", "경우의 수"

**DP 정의:** `dp[i] = i를 만드는 경우의 수`

**점화식:** `dp[i] = sum(이전 상태들)` (더하기!)

**예시 문제:**
- 2×n 타일링 (타일 채우는 방법의 수)
- 동전1 (동전으로 금액 만드는 경우의 수)
- 피보나치 (n번째 수)

### 유형 3: 가능/불가능 판단

**특징:** "~할 수 있는가?", "만들 수 있는가?"

**DP 정의:** `dp[i] = i를 만들 수 있는지 (true/false)`

**점화식:** `dp[i] = 이전 상태 중 하나라도 true면 true`

---

## 자주 하는 실수

### 1. DP 배열 정의를 애매하게 함
❌ "dp[i] = i일 때의 값"
✅ "dp[i] = i번째 계단을 밟았을 때 최대 점수"

### 2. 인덱스 헷갈림
- 0-indexed vs 1-indexed 주의
- 배열 크기 `n+1`로 만들기 (1-indexed 사용 시)

### 3. 초기값을 잘못 설정함
- 최댓값 문제: `dp[0] = 0` 또는 `-Infinity`
- 최솟값 문제: `dp[0] = 0` 또는 `Infinity`
- 경우의 수: `dp[0] = 1` (보통 비어있는 상태 = 1가지)

### 4. 점화식 순서 실수
- 반드시 작은 문제부터 계산해야 함
- 순서를 바꾸면 틀린 답이 나옴

---

## 디버깅 팁

### 1. DP 배열을 출력해보기
```javascript
console.log(dp); // 각 단계마다 값 확인
```

### 2. 손으로 직접 계산해보기
작은 예제 (n=3, n=4)로 직접 계산하고 코드 결과와 비교

### 3. 기저 사례부터 확인
dp[0], dp[1], dp[2]가 올바른지 먼저 확인

---

## 연습 문제 추천 순서

1. **초급 (DP 입문)**
   - 피보나치 수
   - 2×n 타일링
   - 1로 만들기

2. **중급 (패턴 익히기)**
   - 계단 오르기
   - 1, 2, 3 더하기
   - RGB거리

3. **중상급 (응용)**
   - 평범한 배낭
   - 동전1
   - LCS (최장 공통 부분 수열)

---

## 핵심 정리

1. **DP 배열이 무엇을 저장하는지 명확히 정의**
2. **기저 사례를 먼저 채우기**
3. **점화식: 큰 문제 = f(작은 문제들)**
4. **작은 것부터 순서대로 계산**
5. **손으로 작은 예제를 직접 풀어보기**

DP는 패턴 암기가 아니라 **"작은 문제로 나누는 사고방식"**을 익히는 것입니다!

---

## 조합 vs 순열 패턴 (중요!)

### 문제 판별 시그널

| 시그널 | 의미 | DP 패턴 |
|--------|------|---------|
| **"경우의 수를 구하시오"** | 개수 세기 | `dp[i] = 경우의 수` |
| **"몇 개라도 사용 가능"** | 중복 허용 | 동전 순서대로 처리 |
| **"순서 상관없음"** or **"조합"** | (1,2,5) = (5,2,1) | 아이템별 루프 → 금액별 루프 |
| **"순서가 다르면 다른 것"** | (1,2) ≠ (2,1) | 금액별 루프 → 아이템별 루프 |
| **"합이 k가 되도록"** | 특정 값 만들기 | `dp[i - coin]` 활용 |

---

## 세부 패턴별 분류

### 패턴 1: 조합 + 경우의 수 (동전1 타입)

**문제 특징:**
- ✅ 중복 사용 가능
- ✅ 순서 상관없음
- ✅ 경우의 수 구하기

**예제 문제:**
- 백준 2293 - 동전1
- 백준 9084 - 동전

**코드 패턴:**
```javascript
// 동전을 하나씩 추가하면서 경우의 수 계산
for (const coin of coins) {
  for (let i = coin; i <= k; i++) {
    dp[i] += dp[i - coin];
  }
}
```

**핵심:** 동전별 루프가 바깥! → 중복 조합 방지

---

### 패턴 2: 조합 + 최솟값/최댓값

**문제 특징:**
- ✅ 중복 사용 가능
- ✅ 순서 상관없음
- ❌ 경우의 수 X → **최소 개수** 또는 **최대 가치**

**예제 문제:**
- 백준 2294 - 동전2 (최소 동전 개수)
- 백준 12865 - 평범한 배낭 (최대 가치, 단 각 1개씩)

**코드 패턴:**
```javascript
// 최솟값 예시
dp.fill(Infinity);
dp[0] = 0;

for (const coin of coins) {
  for (let i = coin; i <= k; i++) {
    dp[i] = Math.min(dp[i], dp[i - coin] + 1);
  }
}
```

---

### 패턴 3: 순열 + 경우의 수

**문제 특징:**
- ✅ 중복 사용 가능
- ❌ 순서 상관있음 (1,2 ≠ 2,1)
- ✅ 경우의 수 구하기

**예제 문제:**
- 백준 15990 - 1, 2, 3 더하기 5

**코드 패턴:**
```javascript
// 금액별 루프가 바깥! → 순열 허용
for (let i = 1; i <= k; i++) {
  for (const coin of coins) {
    if (i >= coin) {
      dp[i] += dp[i - coin];
    }
  }
}
```

**핵심:** 금액별 루프가 바깥! → (1,2)와 (2,1)을 다르게 셈

---

## 패턴 비교표

| 문제 유형 | 순서 | 중복 | 목표 | 루프 순서 | 점화식 |
|----------|------|------|------|----------|--------|
| **동전1 (조합)** | ❌ 상관없음 | ✅ 가능 | 경우의 수 | 동전 → 금액 | `dp[i] += dp[i-coin]` |
| **동전2 (조합)** | ❌ 상관없음 | ✅ 가능 | 최소 개수 | 동전 → 금액 | `dp[i] = min(dp[i], dp[i-coin]+1)` |
| **1,2,3 더하기 (순열)** | ✅ 상관있음 | ✅ 가능 | 경우의 수 | 금액 → 숫자 | `dp[i] += dp[i-num]` |
| **배낭 (조합)** | ❌ 상관없음 | ❌ 1개씩 | 최대 가치 | 물건 → 무게 | `dp[w] = max(dp[w], dp[w-weight]+value)` |

---

## 문제 판별 체크리스트

```
1. 목표가 무엇인가?
   □ 경우의 수 → dp[i] += ...
   □ 최솟값 → dp[i] = min(...)
   □ 최댓값 → dp[i] = max(...)

2. 순서가 중요한가?
   □ 순서 상관없음 (조합) → 아이템별 루프가 바깥
   □ 순서 상관있음 (순열) → 금액별 루프가 바깥

3. 중복 사용 가능한가?
   □ 몇 개라도 가능 → 일반 DP
   □ 각 1개씩만 → 0/1 배낭 (역순 처리)

4. 키워드 찾기
   □ "방법의 수", "경우의 수" → 경우의 수 DP
   □ "최소 개수", "최소 비용" → 최솟값 DP
   □ "최대 가치", "최대 점수" → 최댓값 DP
```

---

## 동전1 타입 문제 예시

### 예시 1: 동전1 (백준 2293)
```
문제: n가지 동전으로 k원을 만드는 경우의 수
입력: 동전 [1, 2, 5], k = 10
출력: 10

시그널:
✅ "경우의 수" → dp[i] = 경우의 수
✅ "적절히 사용" → 중복 가능
✅ 순서 언급 없음 → 조합 (1+2+5 = 5+2+1)

패턴: 조합 + 경우의 수
루프: 동전 → 금액
```

### 예시 2: 동전2 (백준 2294)
```
문제: k원을 만드는 최소 동전 개수
입력: 동전 [1, 5, 12], k = 15
출력: 3 (5+5+5)

시그널:
✅ "최소 개수" → dp[i] = 최소 개수
✅ "사용하려고 한다" → 중복 가능
✅ 순서 언급 없음 → 조합

패턴: 조합 + 최솟값
루프: 동전 → 금액
```

### 예시 3: 1,2,3 더하기 (백준 9095)
```
문제: n을 1,2,3의 합으로 나타내는 방법의 수 (순서 다르면 다름)
입력: n = 4
출력: 7 (1+1+1+1, 1+1+2, 1+2+1, 2+1+1, 2+2, 1+3, 3+1)

시그널:
✅ "방법의 수" → dp[i] = 경우의 수
✅ 중복 가능
❌ 순서 다르면 다른 것 → 순열 (1+2 ≠ 2+1)

패턴: 순열 + 경우의 수
루프: 금액 → 숫자
```

---

## 핵심 정리

### 조합 (Combination) - 순서 상관없음
```javascript
// 동전별 루프가 바깥
for (const coin of coins) {
  for (let i = coin; i <= k; i++) {
    dp[i] += dp[i - coin];  // 또는 min/max
  }
}
```
**결과:** (1,2,5) = (5,2,1) = (2,1,5) → 같은 것으로 취급

### 순열 (Permutation) - 순서 상관있음
```javascript
// 금액별 루프가 바깥
for (let i = 1; i <= k; i++) {
  for (const coin of coins) {
    if (i >= coin) {
      dp[i] += dp[i - coin];
    }
  }
}
```
**결과:** (1,2) ≠ (2,1) → 다른 것으로 취급

### 루프 순서만 바꿔도 결과가 완전히 달라진다!

문제를 보고 "조합인가 순열인가?"를 먼저 판단하세요!
