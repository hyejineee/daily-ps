# 동적 프로그래밍 (DP) 완벽 가이드

## 목차
1. [DP란 무엇인가](#dp란-무엇인가)
2. [DP 문제 판별법](#dp-문제-판별법)
3. [DP 사고 과정 5단계](#dp-사고-과정-5단계)
4. [자주 나오는 패턴](#자주-나오는-패턴)
5. [흔한 실수](#흔한-실수)
6. [문제 유형별 접근법](#문제-유형별-접근법)
7. [최적화 팁](#최적화-팁)

---

## DP란 무엇인가

### 핵심 개념
- **Memoization**: 한 번 계산한 결과를 저장해서 재사용
- **최적 부분 구조**: 큰 문제의 최적해가 작은 문제의 최적해로 구성됨
- **중복 부분 문제**: 같은 계산을 여러 번 반복

### DP vs 분할 정복
```
분할 정복: 부분 문제가 독립적 (ex: 병합 정렬)
DP: 부분 문제가 겹침 (ex: 피보나치)
```

---

## DP 문제 판별법

다음 키워드가 있으면 DP를 의심하세요:

✅ **확실한 신호**
- "최소/최대 ~를 구하시오"
- "경우의 수를 구하시오"
- "가능한지 판단하시오"
- "최적의 ~를 구하시오"

✅ **문제 특성**
- N이 작거나 중간 크기 (보통 N ≤ 10,000)
- 완전 탐색하면 시간 초과
- 이전 결과가 다음 결과에 영향

---

## DP 사고 과정 5단계

### 1단계: 문제 이해
```
예: "정수 N을 1로 만드는 최소 연산 횟수"
→ 최적화 문제 + 최소값 → DP 냄새!
```

### 2단계: 작은 케이스 직접 풀기
```javascript
// 손으로 풀어보기
dp[1] = 0
dp[2] = 1
dp[3] = 1
dp[4] = 2
dp[5] = 3
dp[6] = 2 // 6→3→1 또는 6→2→1
```

**왜 중요한가?**
- 패턴을 발견하는 가장 빠른 방법
- 점화식의 힌트를 찾을 수 있음
- 초기값(base case)을 명확히 알 수 있음

### 3단계: 관계 찾기 (핵심!)

**순방향 vs 역방향 사고**

❌ **순방향** (N을 어떻게 만들지?)
```
N → ? → ? → 1
너무 많은 경로, 복잡함
```

✅ **역방향** (N은 어디서 왔을까?)
```
? → N
N에 도달하는 방법은 제한적!
```

**예시: "1로 만들기"**
```javascript
// N을 1로 만들기 = N에서 갈 수 있는 곳 중 최소값
dp[6] = 1 + min(
  dp[3],  // 6 ÷ 3
  dp[2],  // 6 ÷ 2
  dp[5]   // 6 - 1
)
```

### 4단계: 점화식 세우기
```javascript
dp[N] = 1 + Math.min(
  N % 3 === 0 ? dp[N/3] : Infinity,
  N % 2 === 0 ? dp[N/2] : Infinity,
  dp[N-1]
)
```

**체크리스트:**
- [ ] Base case 정의 (dp[1] = 0)
- [ ] 조건 확인 (나누어떨어지는지)
- [ ] 범위 검증 (N-1이 0 이상인지)

### 5단계: 구현
```javascript
const solution = (n) => {
  const dp = new Array(n + 1).fill(0);

  for (let i = 2; i <= n; i++) {
    // 1을 빼는 경우
    dp[i] = dp[i - 1] + 1;

    // 2로 나누는 경우
    if (i % 2 === 0) {
      dp[i] = Math.min(dp[i], dp[i / 2] + 1);
    }

    // 3으로 나누는 경우
    if (i % 3 === 0) {
      dp[i] = Math.min(dp[i], dp[i / 3] + 1);
    }
  }

  return dp[n];
};
```

---

## 자주 나오는 패턴

### 패턴 1: 1차원 DP (선형)
```javascript
// 계단 오르기, 피보나치
dp[i] = dp[i-1] + dp[i-2]
```

**특징:**
- 이전 1~2개 값으로 현재 값 결정
- 공간 최적화 가능 (변수 2~3개로)

### 패턴 2: 2차원 DP (격자, 문자열)
```javascript
// LCS, 배낭 문제
dp[i][j] = max(dp[i-1][j], dp[i][j-1])
```

**특징:**
- 2개의 인덱스 필요
- 표를 그려서 이해하면 쉬움

### 패턴 3: 최소/최대 경로
```javascript
// 최소 비용, 최단 경로
dp[i] = min(dp[i-1], dp[i-2], ...) + cost[i]
```

**특징:**
- 누적값에 현재값 더하기
- 초기값 Infinity 또는 -Infinity

### 패턴 4: 경우의 수
```javascript
// 동전 교환, 조합
dp[i] += dp[i - coin]
```

**특징:**
- 더하기 연산 (+)
- 초기값 0 또는 1

### 패턴 5: 가능 여부
```javascript
// 부분합, 달성 가능
dp[i] = dp[i] || dp[i - num]
```

**특징:**
- boolean 값
- 초기값 false

---

## 흔한 실수

### ❌ 실수 1: Base Case 빠뜨리기
```javascript
// 잘못된 코드
const dp = new Array(n + 1); // undefined로 채워짐
dp[0] = 0; // dp[1]을 빠뜨림!
```

✅ **올바른 코드**
```javascript
const dp = new Array(n + 1).fill(0);
dp[0] = 0;
dp[1] = 0; // 명시적으로 초기화
```

### ❌ 실수 2: 순서 틀리기
```javascript
// 배낭 문제 - 중복 사용 방지
for (let i = 1; i <= n; i++) {
  for (let j = coins.length - 1; j >= 0; j--) { // 역순!
    // ...
  }
}
```

### ❌ 실수 3: 인덱스 범위 오류
```javascript
// i-2를 접근하는데 i=1부터 시작
for (let i = 1; i <= n; i++) {
  dp[i] = dp[i-2] + 1; // dp[-1] 접근 에러!
}
```

✅ **올바른 코드**
```javascript
for (let i = 2; i <= n; i++) { // i=2부터 시작
  dp[i] = dp[i-2] + 1;
}
```

### ❌ 실수 4: 초기값 설정 실수
```javascript
// 최소값 문제인데 0으로 초기화
const dp = new Array(n + 1).fill(0); // ❌
dp[i] = Math.min(dp[i], ...); // 항상 0이 최소!
```

✅ **올바른 코드**
```javascript
const dp = new Array(n + 1).fill(Infinity); // ✅
dp[0] = 0; // base case만 0
```

### ❌ 실수 5: 조건 검사 누락
```javascript
// 나눗셈 전 조건 검사 안 함
dp[i] = Math.min(
  dp[i / 2] + 1,  // i가 홀수면 에러!
  dp[i / 3] + 1   // i % 3 !== 0이면 에러!
);
```

✅ **올바른 코드**
```javascript
dp[i] = dp[i - 1] + 1; // 기본값
if (i % 2 === 0) {
  dp[i] = Math.min(dp[i], dp[i / 2] + 1);
}
if (i % 3 === 0) {
  dp[i] = Math.min(dp[i], dp[i / 3] + 1);
}
```

---

## 문제 유형별 접근법

### 유형 1: 계단/경로 문제
**대표 문제:** 계단 오르기, 최소 비용 경로

**접근법:**
```javascript
// 현재 위치 = 이전 위치들 중 최적값
dp[i] = max/min(dp[i-1], dp[i-2]) + cost[i]
```

**팁:**
- 그림 그려서 경로 시각화
- 마지막 한 칸 전/두 칸 전에서 올 수 있음

### 유형 2: 배낭(Knapsack) 문제
**대표 문제:** 0-1 배낭, 동전 교환

**접근법:**
```javascript
// 물건을 넣느냐 vs 안 넣느냐
dp[i][w] = max(
  dp[i-1][w],              // 안 넣음
  dp[i-1][w-weight] + value // 넣음
)
```

**팁:**
- 2차원 표 그리기
- 무게/개수 제한 확인
- 1차원으로 최적화 가능 (역순 순회)

### 유형 3: 문자열 DP
**대표 문제:** LCS, 편집 거리

**접근법:**
```javascript
// 문자가 같으면 vs 다르면
if (s1[i] === s2[j]) {
  dp[i][j] = dp[i-1][j-1] + 1;
} else {
  dp[i][j] = max(dp[i-1][j], dp[i][j-1]);
}
```

**팁:**
- 2차원 표 그리고 대각선/옆/아래 관계 파악
- 인덱스 0을 빈 문자열로 사용

### 유형 4: 구간 DP
**대표 문제:** 행렬 곱셈 순서, 팰린드롬 분할

**접근법:**
```javascript
// 구간 길이를 늘려가며 계산
for (let len = 2; len <= n; len++) {
  for (let i = 0; i <= n - len; i++) {
    let j = i + len - 1;
    // dp[i][j] 계산
  }
}
```

**팁:**
- 길이(len) 기준 반복문
- 분할점(k)으로 구간 나누기

### 유형 5: 비트마스크 DP
**대표 문제:** 외판원 순회(TSP), 집합 경로

**접근법:**
```javascript
// 방문한 도시를 비트로 표현
dp[현재도시][방문상태] = 최소비용
```

**팁:**
- 비트 연산 활용 (1 << i, mask | (1 << i))
- 메모리 주의 (2^n 크기)

---

## 최적화 팁

### 공간 최적화 1: 슬라이딩 윈도우
**Before (O(N))**
```javascript
const dp = new Array(n + 1);
for (let i = 2; i <= n; i++) {
  dp[i] = dp[i-1] + dp[i-2];
}
```

**After (O(1))**
```javascript
let prev2 = 0, prev1 = 1;
for (let i = 2; i <= n; i++) {
  let curr = prev1 + prev2;
  prev2 = prev1;
  prev1 = curr;
}
```

### 공간 최적화 2: 1차원으로 압축
**Before (O(N×M))**
```javascript
const dp = Array.from({length: n}, () => Array(m).fill(0));
for (let i = 1; i <= n; i++) {
  for (let j = 1; j <= m; j++) {
    dp[i][j] = dp[i-1][j] + dp[i][j-1];
  }
}
```

**After (O(M))**
```javascript
const dp = new Array(m).fill(0);
for (let i = 1; i <= n; i++) {
  for (let j = 1; j <= m; j++) {
    dp[j] = dp[j] + dp[j-1]; // 현재 행만 유지
  }
}
```

### 시간 최적화: 필요한 부분만 계산
```javascript
// 모든 dp 값이 필요하지 않다면
if (dp[i] > target) continue; // 가지치기
```

---

## 학습 로드맵

### 1단계: 기초 (쉬움)
- 피보나치 수열
- 계단 오르기
- 1로 만들기 ⭐ (현재)
- 2×n 타일링

### 2단계: 중급 (보통)
- LIS (최장 증가 부분 수열)
- LCS (최장 공통 부분 수열)
- 배낭 문제
- 동전 교환

### 3단계: 고급 (어려움)
- 편집 거리
- 팰린드롬 분할
- 구간 DP
- 비트마스크 DP

---

## 체크리스트

문제를 풀기 전에:
- [ ] DP 문제가 맞는가? (최적화/경우의 수)
- [ ] 작은 케이스 3~5개 손으로 풀어봤는가?
- [ ] 점화식을 말로 설명할 수 있는가?
- [ ] Base case를 명확히 정의했는가?
- [ ] 시간/공간 복잡도를 계산했는가?

구현할 때:
- [ ] 배열 크기 +1 했는가? (인덱스 0 처리)
- [ ] 초기값을 올바르게 설정했는가?
- [ ] 반복문 시작/끝 인덱스가 맞는가?
- [ ] 조건 검사를 했는가? (나눗셈, 범위)
- [ ] 결과값의 위치가 맞는가? (dp[n])

---

## 디버깅 팁

### 1. 작은 케이스 출력
```javascript
console.log(dp.slice(0, 10)); // 처음 10개만 확인
```

### 2. 표로 시각화 (2차원 DP)
```javascript
for (let i = 0; i < n; i++) {
  console.log(dp[i].join(' '));
}
```

### 3. 손으로 계산한 값과 비교
```javascript
// 예상: dp[6] = 2
console.assert(dp[6] === 2, 'dp[6] should be 2');
```

---

## 마무리

**DP의 핵심:**
1. 작은 문제부터 손으로 풀어보기
2. 역방향 사고: "N은 어디서 왔을까?"
3. 점화식을 말로 설명할 수 있어야 함
4. Base case와 조건 검사 꼼꼼히!

**자주 하는 실수:**
- Base case 빠뜨림
- 초기값 잘못 설정 (Infinity vs 0)
- 인덱스 범위 에러
- 조건 검사 누락

**연습 방법:**
- 문제 풀기 전에 손으로 dp[1]~dp[10] 계산
- 점화식을 소리 내어 말하기
- 시각화(표, 그림) 적극 활용
