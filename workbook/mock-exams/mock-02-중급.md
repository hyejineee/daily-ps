# 모의고사 2회 — 중급 종합

> **범위**: Ch01~Ch10 중급
> **제한 시간**: 120분
> **목표**: 복합 패턴 문제를 시간 안에 풀기

---

## 시험 시작 전

- [ ] 타이머 켜기 (120분)
- [ ] 5문제를 먼저 훑어보고 쉬운 것부터 풀기
- [ ] 한 문제에 30분 이상 걸리면 다음으로 넘어가기

---

## 문제 목록

| # | 문제 | BOJ | 주제 | 예상 시간 | 내 시간 | 결과 |
|---|------|-----|------|----------|---------|------|
| 1 | 패션왕 신해빈 | [9375](https://www.acmicpc.net/problem/9375) | 해시 조합 | 15분 | ____분 | [ ] |
| 2 | 오큰수 | [17298](https://www.acmicpc.net/problem/17298) | 모노토닉 스택 | 25분 | ____분 | [ ] |
| 3 | 소수의 연속합 | [1644](https://www.acmicpc.net/problem/1644) | 에라토스테네스 + 투포인터 | 25분 | ____분 | [ ] |
| 4 | 계단 오르기 | [2579](https://www.acmicpc.net/problem/2579) | DP | 20분 | ____분 | [ ] |
| 5 | 다리 만들기 | [2146](https://www.acmicpc.net/problem/2146) | BFS × 2 | 35분 | ____분 | [ ] |

**총 소요 시간**: ____분 / 120분

---

## 풀이 후 점검

### 문제 1: 패션왕 신해빈 (BOJ 9375)
**접근**: 부위별 의상 개수 카운팅 → (각 부위 옷 수 + 1)의 곱 - 1
```
(착용하는 경우) = (각 부위: 옷1개, 옷2개, ..., 착용안함) 의 모든 조합
= 각 부위별 (count + 1) 의 곱 - 1 (전부 착용 안한 경우 제외)
```
**핵심 코드**:
```js
const categories = new Map();
for (const [name, category] of items) {
  categories.set(category, (categories.get(category) || 0) + 1);
}
let result = 1;
for (const count of categories.values()) {
  result *= (count + 1);
}
console.log(result - 1); // 모두 안 입는 경우 제외
```

---

### 문제 2: 오큰수 (BOJ 17298)
**접근**: 모노토닉 스택 — 오른쪽 첫 번째 큰 수
```
스택에 인덱스를 저장, 현재 값이 스택 top의 값보다 크면
스택을 pop하면서 그 위치의 정답에 현재 값을 기록
```
**실수 포인트**: 스택에 인덱스를 저장해야 함 (값이 아니라!)

---

### 문제 3: 소수의 연속합 (BOJ 1644)
**접근**:
1. 에라토스테네스의 체로 소수 목록 구하기
2. 소수 배열에서 투포인터 (같은 방향)로 합이 N인 구간 카운팅
**핵심**:
```js
const primes = sieve(n);
let left = 0, right = 0, sum = 0, count = 0;
while (right <= primes.length) {
  if (sum === n) { count++; sum -= primes[left++]; }
  else if (sum < n) sum += primes[right++];
  else sum -= primes[left++];
}
```

---

### 문제 4: 계단 오르기 (BOJ 2579)
**접근**: 조건부 DP — 연속 3개 불가
```
dp[i] = i번째 계단을 밟았을 때 최대 점수
- dp[i] = dp[i-2] + stairs[i]          (i-1 밟지 않고 i)
- dp[i] = dp[i-3] + stairs[i-1] + stairs[i]  (i-1, i 연속으로 밟기)
```

---

### 문제 5: 다리 만들기 (BOJ 2146)
**접근**: BFS 두 번
1. 각 섬에 번호 매기기 (DFS/BFS)
2. 각 섬의 경계에서 BFS로 다른 섬까지의 최단 거리 탐색
**핵심**: 물 칸(0)을 통해 이동, 다른 섬(다른 번호)에 도달하면 거리 기록

---

## 오답 노트

| 문제 | 틀린 이유 | 올바른 접근 |
|------|----------|------------|
| | | |
